using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Snail
{
    public class SnailSolution
    {
        //Метод возвращает элементы исходного массива массивов, расположенные от крайних элементов к среднему элементу, при движении по часовой стрелке.
        //Метод работает следующим образом: представим массив массивов в виде матрицы; тогда в результирующий массив копируется вехний ряд матрицы;
        //далее верхний ряд матрицы отбрасываем, уменьшенную матрицу разворачиваем на 90 градусов против часовой стрелки (т.е. самый правый столбец становится самым верхним рядом, 
        //столбец, расположенный левее самого правого, переносим на ряд ниже и т.д.) и так до тех пор, пока в матрице не останется элементов.

        public static int[] Snail(int[][] array)
        {
            //Если исходная матрица пуста, то возвращается пустой одномерный массив
            if (array.Length == 0)
                return new int[0];
            else if (array.Length == 1 && array[0].Length == 0)
                return new int[0];

            //Объявляем результирующий одномерный массив. Сюда будут добавляться элементы, расположенные друг за другом при обходе исходной матрицы по часовой стрелке.
            int[] resultArray = new int[(int)Math.Pow(array.Length,2)];

            //Рузультирующий массив заполняется постепенно, порциями элементов, поэтому следует запоминать индекс, до которого массив уже заполнен. 
            //При первой итерации массив заполняется с нулевого индекса.
            int startIndex = 0;

            while (array.Length > 0)
            {
                //Верхний ряд матрицы копируется в результирующий массив, начиная с указанного индекса в результирующем массиве.
                array[0].CopyTo(resultArray, startIndex);
                
                //Индекс старта копирования в следующей итерации, увеличиваем на количество добавленных элементов в текущей итерации (это количество равно длине верхнего ряда матрицы).
                startIndex += array[0].Length;

                //Матрица разворачивается на 90 градусов против часовой стрелки; далее оперируем с полученной матрицей
                array = Rotate2DArray(array);
            }
            
            
            return resultArray;
        }


        //Метод, разворачивающий матрицу на 90 градусов против часовой стрелки, при этом верхний ряд матрицы отбрасывается
        public static int [][] Rotate2DArray(int[][] sourceArray)
        {
            //Объявляем матрицу, которая соответствует исходной матрице (без верхнего ряда), развернутой на 90 градусов. 
            //Количество столбцов будет равно количеству элементов в верхнем ряду исходной матрицы.
            var rotatedArray = new int[sourceArray[0].Length][];

            //В цикле осуществляется проход с права на лево по столбцам исходной матрицы. Столбцы исходной матрицы становятся рядами результирующей матрицы
            for (int i = sourceArray[0].Length - 1, k = 0; i >= 0; i--, k++)
            {
                //Элементы из столбцов исходной матрицы помещаются в данный массив.
                var array = new int[sourceArray.Length-1];

                //Заполняем массив элементами
                for (int j = 0; j < array.Length; j++)
                {
                    array[j] = sourceArray[j + 1][i];
                }

                //Полученный массив добавляем результирующий массив
                rotatedArray[k] = array;
            }

            return rotatedArray;
        }
    }
}
