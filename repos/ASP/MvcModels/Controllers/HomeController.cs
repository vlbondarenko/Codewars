using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using MvcModels.Models;


namespace MvcModels.Controllers
{
    #region О пивязке моделей
    /* Привязка моделей - элегантный мост между НТГР-запросом и методами действий С#. 
     * Система привязки моделей опирается на связыватели моделей, которые являются компонентами, 
     * ответственными за предоставление значений данных из одной части запроса или приложения. 
     * Стандартные связыватели моделей ищут значения данных в следующих трех местах: 
            • отправленные данные формы; 
            • переменные маршрутизации; 
            • строки запросов. 
    * Каждый источник данных инспектируется по порядку до тех пор, пока не будет обнаружено значение для аргумента. 
    * В рассматриваемом примере данные формы отсутствуют, поэтому значение в них не может быть найдено. 
    * Но в конфигурации приложения, предусмотрен сегмент маршрутизации по имени id, который позволит системе привязки моделей 
    * снабдить инфраструктуру MVC значением, подлежащим применению при вызове метода Index (). 
    * После того, как найдено подходящее значение. поиск останавливается, т.е. строка запроса небудет просматриваться 
    * на предмет наличия в ней значения данных. 
    * Привязка моделей является негарантированным средством. т.е. MVC будет применять его в попытке получить значения 
    * необходимые для вызова метода действия. но все равно вызовет метод, даже если значения данных предоставить не удалось.
    * Это может приводить к непредсказуемому поведению. Например. запрос URL вида / Home /Index генерирует исключение.
    * Исключение было инициировано не системой привязки моделей. Взамен оно произошло при обработке представления Index. 
    * выбранного методом действия Index () . Чтобы вызвать метод Index (). инфраструктура MVC должна обеспечить значение 
    * для аргумента id, а потому она предлагает каждому связывателю модели проинспектировать свою часть запроса и предоставить значение. 
    * В примере отсутствуют данные формы, не указано значение для сегмента маршрутизации id и нет строки запроса в URL, 
    * так что система привязки моделей не в состоянии предоставить значение данных. Чтобы вызвать метод Index (), 
    * инфраструктура MVC обязана предоставить какое-нибудь значение для аргумента id, поэтому она использует стандартное 
    * значение и надеется на лучшее. Стандартным значением для аргументов int является О, что и приводит к генерации исключения.
    * В методе Index () значение аргумента id применяется при извлечении объекта модели из хранилища. 
    * Когда MVC использует стандартное значение, метод действия пытается извлечь объект модели с id, равным О. 
    * Такой объект не существует. из-за чего хранилище возвращает значение null, которое затем передается методу View () 
    * контроллера. чтобы указать данные модели представления для представления Index. cshtml. 
    * Когда выражение Razor в файле Index. cshtml пытается обратиться к свойствам объекта модели представления, 
    * возникает исключение NullReferenceException
    */
    #endregion


    public class HomeController : Controller
    {
        private IRepository repository;
        
        public HomeController(IRepository repo)
        {
            repository = repo;
        }

        //При переходе на url вида Home/Index будет выбрасываться исключение
        /* public ViewResult Index(int id) => View(repository[id]);*/

        //Здесь исключение возникать не будет
        public ViewResult Index(int id) => View(repository[id] ?? repository.People.First());


        //Второй способ по предотвращению неожиданного повведения при передачи в качестве аргумента значений, не преобразуемых
        //в int, передачи значения 0 или же отсутствия значения для парамера id   
        /*  public IActionResult Index(int? id)
          {
              Person person;
              if (id.HasValue && (person = repository[id.Value]) != null)
                  return View(person);
              else
                  return NotFound();
          }*/

        public ViewResult Create() => View();

        [HttpPost]
        public ViewResult Create(Person model) => View("Index", model);

        //При поиске значений для свойств объекта AdressSummary без атрибута Bind будет приводить к тому, что при 
        //визуализации представления DisplaySummary будут пустые поля. Так как форма передает значения для свойств
        //City и Country с префиксом HomeAress (например полное имя сво ства будет HomeAdress.City), а объект, 
        //передаваемый в качестве аргумента метода действия ожидает значения для полей без префикса.
        //Таким образом для передачи значений свойствам объекта AdressSummary, нужно явно указать префикс.
        public ViewResult DisplaySummary([Bind(Prefix = nameof(Person.HomeAdress))] AdressSummary summary) =>
            View(summary);

        //Привязка массивов к методам действия
        /*public ViewResult Names(string[] names) => View(names ?? new string[0]);*/

        //Привязка коллекций 
        public ViewResult Names(IList<string> names) => View(names ?? new List<string>());

        //Привязка коллекцийсложных типов
        public ViewResult Address(IList<AdressSummary> adresses) =>
            View(adresses ?? new List<AdressSummary>());

        //Явный выбор заголовков в качестве источников данных привязки при помощи атрибута FromHeader. Поиск данных в других местах 
        //осуществляться не будет.Можно ьакже указать имя параметра заголовка с которым будет связан процесс привязки.
        //Например, так как связыватель модели полагается на имя параметра и совпадение имени параметра метода и имени 
        //параметра в http-заголовке будет приводить к привязке данных. Но, доступ к свойству заголовка, такому как 
        //Accept-Language не получится через имя параметра, так как  Accept-Language - неприменимое имя для параметра метода, а
        //AcceptLanguage - такое имя давать совпадения не будет. Поэтому применяется явное имя свойства http-запроса.
        //[Fromheader(Name="Accept-Language")] - такой атрибут нужно применять для получения доступа к нужному свойству http-запроса
        /* public string Header([FromHeader] string accept) => $"Header:{accept}";*/

        //Другой способ получения данных из заголовка: к свойствам объекта, передаваемого в качестве аргумента,
        //применены атрибуты, которые указывают связывателю моделей источник для привязки данных
        public ViewResult Header(HeaderModel header) => View(header);

        public ViewResult Body() => View();

        [HttpPost]
        public Person Body([FromBody] Person model) => model;

    }
}
